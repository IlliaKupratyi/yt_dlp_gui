import re

from src.core.data_class.subtitle import Subtitles
from src.core.flags.list_subs_flag import ListSubsFlag
from src.core.runner import YTDLPRunner



class SubtitlesLister:
    # Regular expression to split on sequences of 2 or more whitespace characters.
    _WHITESPACE_GROUP_RE = re.compile(r'\s{2,}')

    def __init__(self, yt_dlp_path: str = "yt-dlp"):
        self.runner = YTDLPRunner(yt_dlp_path)
        self.subtitles_str: list[str] = []

    """
    Fetch and parse available subtitles for the given video URL.
    Returns a Subtitles object containing both manual and auto-generated subtitles.
    """
    def get_subtitles(self, url: str = "") -> Subtitles:
        def collect_line(line: str) -> None:
            self.subtitles_str.append(line)

        self.runner.add_flag(ListSubsFlag())
        result = self.runner.run(url, on_output=collect_line)

        if result['return_code'] != 0:
            raise RuntimeError(f"yt-dlp failed: {' '.join(result['stderr'])}")

        return self._parse_output()

    """
    Parse the full yt-dlp output to extract two subtitle lists:
    - Manually uploaded subtitles
    - Auto-generated (automatic) captions
    """
    def _parse_output(self) -> Subtitles:
        autogenerated_subtitles = self._get_subtitles("[info] Available automatic captions for ")
        available_subtitles = self._get_subtitles("[info] Available subtitles for ")

        return Subtitles(available_subtitles,autogenerated_subtitles)

    """
    Extract subtitle entries that appear after a given section prefix.
    Parses lines into dictionaries with 'Language', 'Name', and 'Formats'.
    Uses multi-whitespace splitting to correctly handle names with spaces.
    """
    def _get_subtitles(self, prefix: str = "") -> list[dict[str, str]]:
        subs: list[dict[str, str]] = []
        in_table = False

        for line in self.subtitles_str:
            if not isinstance(line, str):
                continue

            if line.startswith(prefix) and len(line) > len(prefix):
                in_table = True
                continue

            if not in_table:
                continue

            if line.strip().startswith("Language"):
                continue

            if not line.strip():
                break

            parts = self._WHITESPACE_GROUP_RE.split(line.strip())

            if len(parts) < 3:
                continue  # некорректная строка

            language = parts[0]
            name = parts[1]
            formats_raw = parts[2]

            formats = " ".join(f.strip() for f in formats_raw.split(",") if f.strip())

            subs.append({
                "Language": language,
                "Name": name.strip(),
                "Formats": formats
            })

        return subs
